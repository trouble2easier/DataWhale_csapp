
编译器（gcc，clang等）将高级语言如c语言编写的代码，按照目标机器的指令集（IA32，AT&T等）输出汇编代码文件，根据汇编代码生成可执行的机器代码。
高级语言编写的程序为什么能在不同的机器上执行，就是因为生成不同机器对应的汇编代码形式。
为什么要学会阅读和理解汇编代码？
1）阅读汇编代码，可以理解编译器的优化能力，分析代码中隐含的低效率。
2）可以了解程序运行时行为，比如并发程序运行时，不同线程是如何共享程序数据或者保持数据私有等。
本章流程：
1）c语言，汇编代码和机器代码之间的关系
2）数据的表示和处理，控制如if,while,switch的实现
3）程序如何维护一个栈来支持函数执行过程中数据和控制的传递
4）如何实现数组，结构和联合这样的数据结构。
5）内存访问越界问题
6）GDB调试检查程序运行时行为的技巧
begin
1）IA32是Intel公司1985年提出的机器级语言。而IA32的64位扩展是Intel64也成为x86-64.
编译器将c语言编写的代码翻译成汇编代码形式，并进而生成可执行的二进制机器代码。
2）c语言的基本数据类型对应的x86-64表示
c			汇编代码后缀
char		b
short		w
int			l
long		q
char*		q
float		s
double		l
以上，b表示8bit，w表示16位，l表示32位，q表示64位，单精度用s表示32位，双精度用l表示64位。
一个x86-64的cpu包含16个存储64位值的寄存器，每个寄存器都有不同的作用。
所有寄存器的低位部分都可作为字节，16位，32位和64位来访问。
指令的操作数：指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。
操作数分为三种类型：立即数，表示常数值；寄存器，表示寄存器内容；内存引用。
其中寄存器类型的操作数，用R[寄存器]表示寄存器寻址；
内存引用类型的操作数，用M[Imm(rb,ri,s)]表示内存,rb表示基址寄存器，ri表示变址寄存器，s表示比例因子。
例题：
地址	值
0x100  	0xFF
0x104 	0xAB
0x108	0x13
0x10c	0x11
寄存器	值
%rax	0x100
%rcx	0x1
%rdx	0x3
那么操作数对应的值为
%rax				0x100(寄存器寻址)			
0x104				0xAB(绝对寻址)
$0x108				0x108(立即数寻址)
(%rax)				0xFF(间接寻址)
4(%rax)				0x104（基址+偏移量）寻址
9(%rax,%rdx)		0x11(变址寻址)
260(%rcx,%rdx)		0x13(变址寻址)
0xFC(,%rcx,4)		0xFF（比例变址寻址）
(%rax,%rdx,4)		0x11(比例变址寻址)
数据传送指令：
movb
movw
movl
movq
b表示传送8bit，w表示传送16位，l表示传送32位，q表示传送64位。
压入和弹出栈数据：pushq，popq
整数算数操作：leaq，INC，DEC，NEG，NOT，ADD，SUB，IMUL，XOR，OR，AND，SAL，SHL，SAR，SHR
其中lea操作表示加载有效地址，从内存读数据到寄存器,为可执行加法和有限的乘法。
例题：
%rax x
%rcx y
表达式 					值
leaq 6(%rax),%rdx      	x+6
leaq(%rax,%rcx),%rdx	x+y
leaq(%rax,%rcx,4),%rdx	x+4*y
leaq 7(%rax,%rax,8),%rdx 63x
leaq 0xA(,%rcx,4),%rdx   4y+10
leaq 9(%rax,%rcx,2)		9x+18y
控制：
jump可以改变一组机器代码指令的执行顺序。
条件码寄存器：
CF:进位标志，最高位产生了进位。
ZF：零标志
SF：符号标志
OF：溢出标志：补码溢出-正溢出或者负溢出。
访问条件码的方式：a）根据条件码的组合，将一个字节设置为0，或者1；
b）条件跳转到程序的某个其他部分
c）有条件的传送数据。
3）过程P调用过程Q，Q执行后返回到P。
其中有三个机制：转移控制，传递数据，分配和释放内存。
p调用Q：把返回地址压栈，指标当从Q中返回时，要从P程序的哪一位置继续执行。
转移控制过程，把程序计数器设置为Q的代码起始位置。当从Q返回时，处理器必须记录好继续执行p的位置。
call指令会把地址A压入栈中，并把pc设为Q的起始地址，A地址被称为返回地址。
ret指令从栈中弹出A地址，并把pc设为A
数据传送：运行时栈提供了一种简单的，在需要时分配，函数完成时释放局部存储的机制，并将寄存器作为所有过程唯一共享的资源。
