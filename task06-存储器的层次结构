存储器的层次结构
RAM：random access memory
SRAM：static random access memory
DRAM:dynamic random access memory
易失性存储器和非易失性存储器：前者断电会丢失信息，后者则不。
cpu周期，指令周期（机器周期），时间周期的区别：
cpu周期：一个指令取出并执行的时间
指令周期：一个指令的执行被划分为若干阶段，每一阶段所需时间
时钟周期：处理操作的最小单位
对一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个cpu周期。取出指令至少需要一个cpu周期，
执行至少也需要一个cpu周期，复杂的指令需要更多的cpu周期。而一个cpu周期是若干时钟周期之和。
存储技术，性能：SRAM快于DRAM，DRAM快于磁盘。价格：SRAM高于DRAM，DRAM高于磁盘
多核处理器的提出：之前采用提高时钟频率来降低cpu周期时间，但提高到一定程度后再提高会导致功耗过大。多核cpu的提出，使cpu周期时间升高后又以一定频率下降。
基于局部性原理，采用基于SRAM的高速缓存来弥补处理器-内存之间的差距。
局部性：计算机程序倾向于引用邻近最近引用过的数据项。分为时间局部性和空间局部性。
硬件层，根据局部性引入高速缓存存储器；
软件层：web服务器将最近被请求文档放在磁盘高速缓存中。
对程序数据引用的局部性：数组中的数据被保存在连续内存中，访问具备时间局部性和空间局部性
取指令的局部性：程序指令存放在内存中，cpu必须取出这些指令。比如循环指令，按照连续内存殊勋执行，具有良好的空间局部性；循环会被执行多次，也具有时间局部性。
存储器的层次结构：寄存器 -L1高速缓存（SRAM）-L2高速缓存（SRAM）-L3高速缓存（SRAM）-主存（DRAM）-本地磁盘-分布式文件系统，Web服务器
从左到右，速度更慢，容量更大，每字节成本更低。
数据在层次结构中以块大小为传送单元，在第k和第k+1层来回复制。L0和L1之间通常使用1字大小的块；
L1和L2之间的传送通常采用几十个字节的块。
缓存命中cache hit：可以在当前层中找到该数据对象
缓存不命中cache miss，LRU替换策略，从k+1层复制并覆盖k层一个现有的块。

x32位机器linux虚拟地址空间大小为4GB，即最大寻址空间为4G，1G=1024MB，1MB=1024KB,1KB=1024B,2的32次方/2的10次方/2的10次方/2的10次方=4G
高速缓存存储器的组织结构
一个高速缓存有S=2的s次方个缓存组（cache set），每个缓存组有E个缓存行，每行有B=2的b次方个数据块。
高速缓存器的容量C=S*E*B
每行一个有效位，有效位为0，表示此行中无数据块。
物理地址m位，m=t+s+b,标记位告诉我们组中哪一行包含这个字

练习题6.9计算高速缓存组数S，标记位数t，组索引位数s以及块偏移位数b
m       C               B       E               S               t              s            b
32      1024        4       1               256               16              8            2
32      1024        8       4               32                24             5             3
32      1024        32      32              1                27             0              5
直接映射高速缓存：E=1
组相联高速缓存：1<E<C/B
全相联高速缓存：S=1，E=C/B，只适合做小的高速缓存，如TLB，用来缓存页表项。

模拟cpu执行一系列读的时候，组相联高速缓存执行过程：
初始时，高速缓存为空，此时每行有效位都是0。根据物理地址，转化为2进制，确定对应组号，标志位，块偏移。
确定相应组后，搜索组中每一行寻找一个有效行，并用物理地址标记位与缓存中标记位匹配，如果找到这一行，根据块偏移选择一个字。
如果，cpu请求的字不在任何一行，就是缓存不命中。从内存中取出包含这个字的块，替换缓存中的空行，
如果没有空行，采用LRU策略，替换。

以上是高速缓存关于读操作，那么关于写操作：略。
高速缓存按照保存内容，分为只保存指令的高速缓存i-cache，只保存程序数据的高速缓存d-cache
core i7高速缓存层次结构：每个CPU芯片有四个核，每个核有L1 i-cahce，L1 d-cache，和L2高速缓存。所有核共享L3高速缓存。

编写高速缓存友好的代码：
1）集中核心函数的循环上
2）尽量减少每个循环内部的缓存不命中数量:对局部变量的反复引用（时间局部性）；步长为1考虑空间局部性。

