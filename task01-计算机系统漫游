简要介绍一下hello.c在x86-64机器运行过程
#include<stdio.h>
int main()
{ 
  printf("hello world\n");
  return 0;
}
1.1  hello.c的源文件是如何存储的？
  ASCII码的编码方式将每个字符转化为一个整数，而这个整数是由8bit的01序列表示（8bit就是一个字节）。
  文本文件是ASCII码形式的文件，二进制文件是01形式的文件。
  系统中所有信息都可以由一串bit表示。
1.2   源文件怎么变成可执行文件？
  hello.c的源文件通过编译器驱动经过4个过程转化为可执行程序。这四个过程分别为预处理，编译，汇编，链接。
  预处理：读取头文件插入源文件代码中，生成hello.i文件
  编译:将文本文件即其他高级语言编写的代码翻译成汇编语言形式，生成hello.s
  汇编:将汇编形式文件翻译成机器指令的二进制文件，打包成可重定位目标文件hello.o
  链接:将多个可重定位目标文件链接在一起生成可执行文件
  不同的编译器驱动表示不同的环境，比如x86linux，Android,qnx等。
1.3   为什么要了解编译系统（编译器驱动的工作过程）？
    1）理解不同语句的编写在转化为可执行文件的过程中，编译驱动是如何优化性能的。
    2）构建大型软件系统时，总会出现undefined reference等错误，找出出现这样错误的原因。
    3）在接收不同格式和数量的数据时，会出现缓冲区溢出。理解数据和控制信息是如何存储在程序栈的方式，可以帮助我们避免和解决这样的问题。
1.4   运行可执行文件的过程发生了什么？
  在shell终端，输入./hello，shell将输入字符读入寄存器并存放到主存；
  输完按下enter键。shell知道命令的输入结束，shell运行指令从磁盘加载执行文件，将hello中的代码和数据复制到主存。
  处理器执行main函数中的机器指令，将"hello world\n"从主存复制到寄存器，再从寄存器复制到显示设备。
1.5   可执行文件运行太慢了，如何加快？  
   缓存加快可执行文件的运行过程。处理器从寄存器读数据要比主存上读要快约100倍，减少上述从主存复制的次数可加快程序的运行。位于处理器芯片上的chache memory存放处理器近期可能会需要的信息。
1.6   存储器层次结构
   寄存器-L1高速缓存-L2高速缓存-L3高速缓存-主存-本地磁盘-远程存储（分布式文件系统，web服务器等）
   从左至右，存储器的容量越来越大，处理器访问速度越来越小。
1.7   可执行程序是如何和硬件交互的？
    依靠操作系统来对硬件进行操作。操作系统通过进程，文件，虚拟内存来实现两个功能：1）防止硬件被应用程序滥用；2）提供简单一致的机制控制多个硬件设备。
    进程：操作系统对正在运行的一个程序的抽象表达，处理器进行进程间的切换来实现同运行多个进程，上下文表示进程运行时的所有状态信息。
    线程：一个进程包含多个线程，线程间共享代码和全局数据。
    虚拟内存：进程所需的4G大小的内容存储在磁盘上，进程工作时，再按需调入主存。
    文件：每个IO设备，包括磁盘，键盘，显示器甚至网络都可以看成文件，系统中的输入输出通过IO的系统函数调用读写文件实现。
1.8   信息通过网络在多个系统中传递。
    最经典的案例是，通过telnet连接远程服务器，在本地客户端输入./hello字符后，远程主机运行hello可执行程序，并把结果发送给客户端，客户端显示运行结果。
1.9   系统是硬件和软件互相交织的集合体
  Amdahl定律：要想加速整个系统，必须提升全系统中相当大部分的速度。计算机的发展需求是：做的更多、更快。即
  并发：同时具有多个活动的系统；
  并行：用并发来使系统运行地更快。
  按照系统层次结构来说分为三部分，
  1）线程级并发
  2）指令级并行
  3）单指令、多数据并行
  
